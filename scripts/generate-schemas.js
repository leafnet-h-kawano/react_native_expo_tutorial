#!/usr/bin/env node

/**
 * common/, requests/, responses/ ãƒ•ã‚©ãƒ«ãƒ€å†…ã®åž‹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰Zodã‚¹ã‚­ãƒ¼ãƒžã‚’ç”Ÿæˆ
 * 
 * å‡¦ç†æ–¹é‡:
 * - ã™ã¹ã¦ã®åž‹ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦ts-to-zodã‚’ä½¿ç”¨ï¼ˆä¸¦åˆ—å‡¦ç†ã§é«˜é€ŸåŒ–ï¼‰
 * - ts-to-zodãŒz.any()ã‚’å‡ºåŠ›ã—ãŸå ´åˆã€é©åˆ‡ãªã‚¹ã‚­ãƒ¼ãƒžã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ç½®æ›
 * 
 * å‡ºåŠ›å…ˆ:
 * - model/schemas/common/ â† common/ã®åž‹ã‹ã‚‰ç”Ÿæˆï¼ˆã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼‰
 * - model/schemas/requests/ â† requests/ã®åž‹ã‹ã‚‰ç”Ÿæˆ
 * - model/schemas/responses/ â† responses/ã®åž‹ã‹ã‚‰ç”Ÿæˆ
 */

const { execSync, exec } = require('child_process');
const fs = require('fs');
const path = require('path');
const { promisify } = require('util');
const execAsync = promisify(exec);

const baseTypesDir = './model/genTypes';
const baseSchemasDir = './model/schemas';

// ts-to-zodã®ãƒ‘ã‚¹ï¼ˆnpxã‚’ä½¿ã‚ãšç›´æŽ¥å®Ÿè¡Œã—ã¦é«˜é€ŸåŒ–ï¼‰
const tsToZodBin = path.resolve(__dirname, '../node_modules/.bin/ts-to-zod');

// ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ç”¨ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆ
const generatedHeader = `/**
 * Generated by ts-to-zod
 * Schema generated by generate-schemas.js
 * Do not edit manually.
 */
`;

// schemasãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
if (fs.existsSync(baseSchemasDir)) {
  fs.rmSync(baseSchemasDir, { recursive: true });
}

// ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
['common', 'requests', 'responses'].forEach(dir => {
  fs.mkdirSync(path.join(baseSchemasDir, dir), { recursive: true });
});

console.log('ðŸ”„ Zodã‚¹ã‚­ãƒ¼ãƒžã‚’ç”Ÿæˆä¸­...\n');

/**
 * åž‹åã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
 * ä¾‹: User â†’ user, GetUserResponse â†’ getUserResponse
 */
function toFileName(typeName) {
  return typeName.charAt(0).toLowerCase() + typeName.slice(1);
}

/**
 * å‚ç…§å…ˆã®åž‹ãŒã©ã®ãƒ•ã‚©ãƒ«ãƒ€ã«ã‚ã‚‹ã‹åˆ¤å®š
 */
function findEntityFolder(entityName) {
  const folders = ['common', 'requests', 'responses'];
  for (const folder of folders) {
    const filePath = path.join(baseTypesDir, folder, toFileName(entityName) + '.ts');
    if (fs.existsSync(filePath)) {
      return folder;
    }
  }
  return 'common'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
}

/**
 * ã‚¹ã‚­ãƒ¼ãƒžåã‹ã‚‰åž‹åã‚’æŽ¨æ¸¬
 * ä¾‹: userAddressSchema â†’ UserAddress
 */
function schemaNameToTypeName(schemaName) {
  const name = schemaName.replace('Schema', '');
  return name.charAt(0).toUpperCase() + name.slice(1);
}

/**
 * ts-to-zodãŒç”Ÿæˆã—ãŸz.any()ã‚’é©åˆ‡ãªã‚¹ã‚­ãƒ¼ãƒžå‚ç…§ã«ç½®æ›
 */
function fixNestedTypes(content, currentFolder) {
  const lines = content.split('\n');
  const fixedLines = [];
  const imports = new Set();
  const localSchemaRemovals = new Set(); // å‰Šé™¤ã™ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚­ãƒ¼ãƒžå®šç¾©
  
  // ã¾ãšã€z.any()ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚­ãƒ¼ãƒžã‚’æ¤œå‡º
  for (const line of lines) {
    // const xxxSchema = z.any(); ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
    const localAnyMatch = line.match(/const (\w+Schema) = z\.any\(\);/);
    if (localAnyMatch) {
      const schemaName = localAnyMatch[1];
      const typeName = schemaNameToTypeName(schemaName);
      const folder = findEntityFolder(typeName);
      const fileName = toFileName(typeName);
      
      // åŒã˜ãƒ•ã‚©ãƒ«ãƒ€å†…ã«å¯¾å¿œã™ã‚‹åž‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      const typeFilePath = path.join(baseTypesDir, folder, fileName + '.ts');
      if (fs.existsSync(typeFilePath)) {
        localSchemaRemovals.add(schemaName);
        const relativePath = currentFolder === folder 
          ? './' + fileName
          : '../' + folder + '/' + fileName;
        imports.add('import { ' + schemaName + ' } from "' + relativePath + '";');
      }
    }
  }
  
  // è¡Œã‚’å‡¦ç†
  for (const line of lines) {
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚­ãƒ¼ãƒžå®šç¾©ã‚’å‰Šé™¤ï¼ˆã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ç½®æ›æ¸ˆã¿ï¼‰
    const localAnyMatch = line.match(/const (\w+Schema) = z\.any\(\);/);
    if (localAnyMatch && localSchemaRemovals.has(localAnyMatch[1])) {
      continue; // ã“ã®è¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
    }
    
    fixedLines.push(line);
  }
  
  // ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’è¿½åŠ 
  if (imports.size > 0) {
    const importSection = Array.from(imports).join('\n');
    const zodImportIndex = fixedLines.findIndex(l => l.includes('import { z }'));
    if (zodImportIndex !== -1) {
      fixedLines.splice(zodImportIndex + 1, 0, importSection);
    }
  }
  
  return fixedLines.join('\n');
}

/**
 * åž‹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰Zodã‚¹ã‚­ãƒ¼ãƒžã‚’ç”Ÿæˆï¼ˆéžåŒæœŸç‰ˆãƒ»ä¸¦åˆ—å‡¦ç†ç”¨ï¼‰
 * 
 * å‡¦ç†ãƒ•ãƒ­ãƒ¼:
 * 1. ts-to-zodã§ã‚¹ã‚­ãƒ¼ãƒžç”Ÿæˆ
 * 2. ãƒ˜ãƒƒãƒ€ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’ç½®æ›
 * 3. z.any()ãŒã‚ã‚Œã°fixNestedTypesã§ä¿®æ­£ï¼ˆã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ç½®æ›ï¼‰
 */
async function generateSchemaForFile(inputPath, outputPath, currentFolder) {
  try {
    // ts-to-zodã§ã‚¹ã‚­ãƒ¼ãƒžç”Ÿæˆï¼ˆéžåŒæœŸã§ä¸¦åˆ—å®Ÿè¡Œï¼‰
    await execAsync(`"${tsToZodBin}" ${inputPath} ${outputPath}`);
    
    // ç”Ÿæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    let generatedContent = fs.readFileSync(outputPath, 'utf8');
    
    // ts-to-zodã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‚«ã‚¹ã‚¿ãƒ ãƒ˜ãƒƒãƒ€ãƒ¼ã«ç½®æ›
    generatedContent = generatedContent.replace(
      /^\/\/ Generated by ts-to-zod\n/,
      generatedHeader
    );
    
    // z.any()ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if (generatedContent.includes('z.any()')) {
      // z.any()ã‚’é©åˆ‡ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆã«ç½®æ›
      const fixedContent = fixNestedTypes(generatedContent, currentFolder);
      fs.writeFileSync(outputPath, fixedContent);
      return { success: true, type: 'fixed', file: path.basename(inputPath) };
    }
    
    fs.writeFileSync(outputPath, generatedContent);
    return { success: true, type: 'generated', file: path.basename(inputPath) };
  } catch (error) {
    return { success: false, error: error.message, file: path.basename(inputPath) };
  }
}

/**
 * ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸¦åˆ—å‡¦ç†ã§ã‚¹ã‚­ãƒ¼ãƒžç”Ÿæˆ
 */
async function processFolderParallel(folder) {
  const typesDir = path.join(baseTypesDir, folder);
  const schemasDir = path.join(baseSchemasDir, folder);
  
  if (!fs.existsSync(typesDir)) {
    console.log('ðŸ“ ' + folder + '/ (ã‚¹ã‚­ãƒƒãƒ— - ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãªã—)');
    return;
  }
  
  console.log('ðŸ“ ' + folder + '/');
  
  // .tsãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ï¼ˆindex.tsä»¥å¤–ï¼‰
  const files = fs.readdirSync(typesDir)
    .filter(f => f.endsWith('.ts') && f !== 'index.ts');
  
  if (files.length === 0) {
    console.log('  (ãƒ•ã‚¡ã‚¤ãƒ«ãªã—)');
    return;
  }
  
  // å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸¦åˆ—å‡¦ç†
  const promises = files.map(file => {
    const inputPath = path.join(typesDir, file);
    const outputPath = path.join(schemasDir, file);
    return generateSchemaForFile(inputPath, outputPath, folder);
  });
  
  const results = await Promise.all(promises);
  
  // çµæžœã‚’è¡¨ç¤º
  results.forEach(result => {
    if (result.success) {
      console.log('  âœ… ' + result.file);
    } else {
      console.error('  âŒ ' + result.file + ': ' + result.error);
    }
  });
  
  // index.tsã‚’ç”Ÿæˆ
  const schemaFiles = fs.readdirSync(schemasDir)
    .filter(f => f.endsWith('.ts') && f !== 'index.ts');
  
  if (schemaFiles.length > 0) {
    const indexContent = generatedHeader + '\n// ' + folder + 'ã®Zodã‚¹ã‚­ãƒ¼ãƒž\n' + schemaFiles.map(f => "export * from './" + f.replace('.ts', '') + "';").join('\n') + '\n';
    fs.writeFileSync(path.join(schemasDir, 'index.ts'), indexContent);
  }
}

// ===== ãƒ¡ã‚¤ãƒ³å‡¦ç†ï¼ˆéžåŒæœŸï¼‰ =====
async function main() {
  // å‡¦ç†é †åº: common â†’ requests â†’ responsesï¼ˆä¾å­˜é–¢ä¿‚ã‚’è€ƒæ…®ï¼‰
  // commonã‚’å…ˆã«å®Œäº†ã•ã›ã¦ã‹ã‚‰ä»–ã‚’ä¸¦åˆ—å‡¦ç†
  await processFolderParallel('common');
  
  // requests ã¨ responses ã¯ä¸¦åˆ—å‡¦ç†å¯èƒ½
  await Promise.all([
    processFolderParallel('requests'),
    processFolderParallel('responses')
  ]);

  // ===== commonç”¨ã®é…åˆ—åž‹ã¨APIã‚¨ãƒ©ãƒ¼ã®ã‚¹ã‚­ãƒ¼ãƒžã‚’è¿½åŠ  =====
  const commonSchemaPath = path.join(baseSchemasDir, 'common');
  const schemaFiles = fs.readdirSync(commonSchemaPath)
    .filter(f => f.endsWith('.ts') && f !== 'index.ts' && f !== 'arrays.ts');

  // é…åˆ—åž‹ã«ä½¿ã†ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’å‹•çš„ã«åˆ¤å®šï¼ˆAddress, Company, Geo ã‚’é™¤ãï¼‰
  const entityFiles = schemaFiles.filter(f => 
    !f.includes('Address') && !f.includes('Company') && !f.includes('Geo') && !f.includes('Error')
  );

  let arraysContent = generatedHeader + '\n// é…åˆ—åž‹ã¨APIã‚¨ãƒ©ãƒ¼ã®Zodã‚¹ã‚­ãƒ¼ãƒž\nimport { z } from "zod";\n';

  // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚¹ã‚­ãƒ¼ãƒžã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  entityFiles.forEach(f => {
    const baseName = f.replace('.ts', '');
    const schemaName = baseName + 'Schema';
    arraysContent += 'import { ' + schemaName + ' } from "./' + baseName + '";\n';
  });

  arraysContent += '\n';

  // é…åˆ—ã‚¹ã‚­ãƒ¼ãƒžã®å®šç¾©
  entityFiles.forEach(f => {
    const baseName = f.replace('.ts', '');
    const schemaName = baseName + 'Schema';
    const pluralName = baseName + 'sSchema';
    arraysContent += 'export const ' + pluralName + ' = z.array(' + schemaName + ');\n';
  });

  arraysContent += '\nexport const apiErrorSchema = z.object({\n  message: z.string(),\n  status: z.number().optional(),\n  code: z.string().optional()\n});\n';

  fs.writeFileSync(path.join(commonSchemaPath, 'arrays.ts'), arraysContent);
  console.log('\n  âœ… common/arrays.ts (é…åˆ—åž‹ãƒ»APIã‚¨ãƒ©ãƒ¼)');

  // ãƒ¡ã‚¤ãƒ³ã®index.tsã‚’ç”Ÿæˆ
  const mainIndexContent = generatedHeader + "\n// Zodã‚¹ã‚­ãƒ¼ãƒžã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ\n\nexport * from './common';\nexport * from './requests';\nexport * from './responses';\n";

  fs.writeFileSync(path.join(baseSchemasDir, 'index.ts'), mainIndexContent);

  console.log('\nâœ… Zodã‚¹ã‚­ãƒ¼ãƒžç”Ÿæˆå®Œäº†!');
  console.log('   common/ â†’ ' + baseSchemasDir + '/common/');
  console.log('   requests/ â†’ ' + baseSchemasDir + '/requests/');
  console.log('   responses/ â†’ ' + baseSchemasDir + '/responses/');
}

// ãƒ¡ã‚¤ãƒ³å‡¦ç†ã‚’å®Ÿè¡Œ
main().catch(err => {
  console.error('ã‚¨ãƒ©ãƒ¼:', err);
  process.exit(1);
});
