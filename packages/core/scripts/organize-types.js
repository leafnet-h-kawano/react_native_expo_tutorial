#!/usr/bin/env node

/**
 * Orvalã§ç”Ÿæˆã•ã‚ŒãŸå˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’
 * common/requests/responsesãƒ•ã‚©ãƒ«ãƒ€ã«åˆ†å‰²ã™ã‚‹
 * 
 * ãƒ«ãƒ¼ãƒ«:
 * - *Request â†’ requests/
 * - *Response â†’ responses/
 * - ãã‚Œä»¥å¤–ï¼ˆã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£å‹ï¼‰ â†’ common/
 */

const fs = require('fs');
const path = require('path');

const sourceFile = './src/model/genTypes/reactNativeTutorialAPI.g.ts';
const baseDir = './src/model/genTypes';

// ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
const dirs = ['common', 'requests', 'responses'];
dirs.forEach(dir => {
  const dirPath = path.join(baseDir, dir);
  if (fs.existsSync(dirPath)) {
    fs.rmSync(dirPath, { recursive: true });
  }
  fs.mkdirSync(dirPath, { recursive: true });
});

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
const content = fs.readFileSync(sourceFile, 'utf8');

// ãƒ˜ãƒƒãƒ€ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆ
const header = `/**
 * Generated by orval v7.17.0 ğŸº
 * Spited by organize-types.js
 * Do not edit manually.
 */
`;

// å…¨ã¦ã®å‹å®šç¾©ã‚’æŠ½å‡ºï¼ˆinterface ã¨ type ã®ä¸¡æ–¹ï¼‰
// 1. interface: export interface Foo { ... }
// 2. type object: export type Foo = { ... }
// 3. type alias: export type Foo = Bar; ã¾ãŸã¯ export type Foo = Bar[];
const types = [];

// interface ã¨ type object ã‚’æŠ½å‡º
const objectTypeRegex = /export (?:interface|type) (\w+)\s*(?:=\s*)?{[^}]*}/gs;
let match;
while ((match = objectTypeRegex.exec(content)) !== null) {
  types.push({
    name: match[1],
    definition: match[0]
  });
}

// type alias ã‚’æŠ½å‡º (export type Foo = Bar; ã¾ãŸã¯ export type Foo = Bar[];)
const typeAliasRegex = /export type (\w+)\s*=\s*([^{][^;]*);/g;
while ((match = typeAliasRegex.exec(content)) !== null) {
  // æ—¢ã«æŠ½å‡ºæ¸ˆã¿ã§ãªã„ã‹ç¢ºèª
  if (!types.some(t => t.name === match[1])) {
    types.push({
      name: match[1],
      definition: match[0],
      isAlias: true,
      aliasTarget: match[2].trim()
    });
  }
}

// å‹ã‚’æŒ¯ã‚Šåˆ†ã‘
const requestTypes = types.filter(t => /Request$/.test(t.name));
const responseTypes = types.filter(t => /Response$/.test(t.name));
const commonTypes = types.filter(t => !/Request$/.test(t.name) && !/Response$/.test(t.name));

// ä¾å­˜é–¢ä¿‚ã‚’è§£æã—ã¦é©åˆ‡ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’è¿½åŠ 
function getImports(definition, availableTypes, currentTypeName) {
  const imports = [];
  availableTypes.forEach(t => {
    if (t.name !== currentTypeName) {
      // å‹å®šç¾©å†…ã§ä»–ã®å‹ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      const regex = new RegExp(`\\b${t.name}\\b`, 'g');
      if (regex.test(definition)) {
        imports.push(t.name);
      }
    }
  });
  return imports;
}

// ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆï¼ˆPascalCase â†’ camelCaseï¼‰
function toFileName(typeName) {
  return typeName.charAt(0).toLowerCase() + typeName.slice(1) + '.g.ts';
}

// Commonå‹ã‚’å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ï¼ˆä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆä»˜ãï¼‰
commonTypes.forEach(type => {
  const filename = toFileName(type.name);
  const imports = getImports(type.definition, commonTypes, type.name);
  
  let fileContent = header + '\n';
  if (imports.length > 0) {
    imports.forEach(imp => {
      const impFileName = toFileName(imp).replace('.ts', '');
      fileContent += `import type { ${imp} } from './${impFileName}';\n`;
    });
    fileContent += '\n';
  }
  fileContent += type.definition + '\n';
  
  fs.writeFileSync(path.join(baseDir, 'common', filename), fileContent);
});

// Requestå‹ã‚’å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›
requestTypes.forEach(type => {
  const filename = toFileName(type.name);
  const fileContent = header + '\n' + type.definition + '\n';
  fs.writeFileSync(path.join(baseDir, 'requests', filename), fileContent);
});

// Responseå‹ã‚’å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›
responseTypes.forEach(type => {
  const filename = toFileName(type.name);
  
  // aliasTargetã¾ãŸã¯definitionã‹ã‚‰ä¾å­˜å‹ã‚’å–å¾—
  const searchText = type.aliasTarget || type.definition;
  const imports = getImports(searchText, [...commonTypes, ...responseTypes], type.name);
  
  let fileContent = header + '\n';
  if (imports.length > 0) {
    imports.forEach(imp => {
      // commonã«ã‚ã‚‹ã‹responsesã«ã‚ã‚‹ã‹åˆ¤å®š
      const isCommon = commonTypes.some(t => t.name === imp);
      const impFileName = toFileName(imp).replace('.g.ts', '');
      const importPath = isCommon ? `../common/${impFileName}.g` : `./${impFileName}.g`;
      fileContent += `import type { ${imp} } from '${importPath}';\n`;
    });
    fileContent += '\n';
  }
  fileContent += type.definition + '\n';
  
  fs.writeFileSync(path.join(baseDir, 'responses', filename), fileContent);
});

// common/index.tsï¼ˆé…åˆ—å‹ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚‚å«ã‚€ï¼‰
let commonIndex = header + '\n' +
  commonTypes.map(t => `export * from './${toFileName(t.name).replace('.g.ts', '.g')}';`).join('\n') + '\n\n';

// é…åˆ—å‹ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’è¿½åŠ ï¼ˆã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£å‹ã®ã¿ï¼‰
const entityTypes = commonTypes.filter(t => 
  !t.name.includes('Address') && !t.name.includes('Company') && !t.name.includes('Geo')
);
if (entityTypes.length > 0) {
  commonIndex += '// é…åˆ—å‹ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹\n';
  entityTypes.forEach(t => {
    commonIndex += `import type { ${t.name} } from './${toFileName(t.name).replace('.g.ts', '.g')}';\n`;
  });
  commonIndex += '\n';
  entityTypes.forEach(t => {
    commonIndex += `export type ${t.name}s = ${t.name}[];\n`;
  });
  commonIndex += '\n';
}

// APIã‚¨ãƒ©ãƒ¼å‹ã‚’è¿½åŠ 
commonIndex += `// APIã‚¨ãƒ©ãƒ¼å‹
export type ApiError = {
  message: string;
  status?: number;
  code?: string;
};
`;

fs.writeFileSync(path.join(baseDir, 'common', 'index.ts'), commonIndex);

// requests/index.ts
const requestsIndex = header + '\n' +
  requestTypes.map(t => `export * from './${toFileName(t.name).replace('.g.ts', '.g')}';`).join('\n') + '\n';
fs.writeFileSync(path.join(baseDir, 'requests', 'index.ts'), requestsIndex);

// responses/index.tsï¼ˆcommonã‹ã‚‰ã®re-exportã‚‚å«ã‚€ï¼‰
let responsesIndex = header + '\n';
// commonã‹ã‚‰re-export
// responsesIndex += '// commonã‹ã‚‰ã®re-exportï¼ˆã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£å‹ï¼‰\n';
// responsesIndex += `export * from '../common';\n\n`;
// Responseå‹
if (responseTypes.length > 0) {
  responsesIndex += '// Responseå‹\n';
  responsesIndex += responseTypes.map(t => `export * from './${toFileName(t.name).replace('.g.ts', '.g')}';`).join('\n') + '\n';
}
fs.writeFileSync(path.join(baseDir, 'responses', 'index.ts'), responsesIndex);

// ãƒ¡ã‚¤ãƒ³index.ts
const mainIndex = `${header}
// å…±é€šå‹ï¼ˆã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼‰
export * from './common';

// ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‹
export * from './requests';

// ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹
export * from './responses';
`;
fs.writeFileSync(path.join(baseDir, 'index.ts'), mainIndex);

// å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
fs.unlinkSync(sourceFile);

console.log('âœ… å‹å®šç¾©ã‚’ãƒ•ã‚©ãƒ«ãƒ€åˆ†ã‘ã—ã¾ã—ãŸ:');
console.log(`  - common/: ${commonTypes.length}ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£å‹ï¼‰`);
console.log(`  - requests/: ${requestTypes.length}ãƒ•ã‚¡ã‚¤ãƒ«`);
console.log(`  - responses/: ${responseTypes.length}ãƒ•ã‚¡ã‚¤ãƒ«`);
console.log('');
console.log('Commonå‹:', commonTypes.map(t => t.name).join(', '));
console.log('Requestå‹:', requestTypes.map(t => t.name).join(', '));
console.log('Responseå‹:', responseTypes.map(t => t.name).join(', ') || '(ãªã—)');


